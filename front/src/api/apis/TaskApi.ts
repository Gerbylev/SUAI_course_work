/* tslint:disable */
/* eslint-disable */
/**
 * Контракт для ОП
 * API для работы с заданиями и тетрадками для нашего маленького (пока ещё!) подобия Stepik. Здесь находится наш скромный функционал, выраженный в возможности создать новые задания, получить всю возможную информацию об уже имеющемся задании по его идентификатору, а также тут происходит связь \"учитель - студент\", когда ученик высылает своё решение (также по идентификатору).
 *
 * The version of the OpenAPI document: Pre-alpha
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CreateTaskData,
  TaskData,
} from '../models/index';
import {
    CreateTaskDataFromJSON,
    CreateTaskDataToJSON,
    TaskDataFromJSON,
    TaskDataToJSON,
} from '../models/index';

export interface CreateTaskRequest {
    taskData?: CreateTaskData;
    notebooks?: Array<Blob>;
}

export interface DeleteTaskRequest {
    taskId: string;
}

export interface EditTaskRequest {
    taskId: string;
    taskData?: CreateTaskData;
    notebooks?: Array<Blob>;
}

export interface GetAllTasksRequest {
    page?: number;
    limit?: number;
    title?: string;
    startDate?: Date;
    endDate?: Date;
    authorName?: string;
    status?: string;
}

export interface GetTaskRequest {
    taskId: string;
}

/**
 * 
 */
export class TaskApi extends runtime.BaseAPI {

    /**
     * Позволяет создать задание, прикрепив текст задачи и Python тетрадку.
     * Создать новое задание для ученика
     */
    async createTaskRaw(requestParameters: CreateTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TaskData>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['taskData'] != null) {
            formParams.append('task_data', new Blob([JSON.stringify(CreateTaskDataToJSON(requestParameters['taskData']))], { type: "application/json", }));
                    }

        if (requestParameters['notebooks'] != null) {
            requestParameters['notebooks'].forEach((element) => {
                formParams.append('notebooks', element as any);
            })
        }

        const response = await this.request({
            path: `/api/task`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TaskDataFromJSON(jsonValue));
    }

    /**
     * Позволяет создать задание, прикрепив текст задачи и Python тетрадку.
     * Создать новое задание для ученика
     */
    async createTask(requestParameters: CreateTaskRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TaskData> {
        const response = await this.createTaskRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Удаляет задание по его идентификатору.
     * Удалить задание
     */
    async deleteTaskRaw(requestParameters: DeleteTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['taskId'] == null) {
            throw new runtime.RequiredError(
                'taskId',
                'Required parameter "taskId" was null or undefined when calling deleteTask().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/task/{taskId}`.replace(`{${"taskId"}}`, encodeURIComponent(String(requestParameters['taskId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Удаляет задание по его идентификатору.
     * Удалить задание
     */
    async deleteTask(requestParameters: DeleteTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteTaskRaw(requestParameters, initOverrides);
    }

    /**
     * Обновляет информацию о задании по его идентификатору.
     * Редактировать задание
     */
    async editTaskRaw(requestParameters: EditTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TaskData>> {
        if (requestParameters['taskId'] == null) {
            throw new runtime.RequiredError(
                'taskId',
                'Required parameter "taskId" was null or undefined when calling editTask().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['taskData'] != null) {
            formParams.append('task_data', new Blob([JSON.stringify(CreateTaskDataToJSON(requestParameters['taskData']))], { type: "application/json", }));
                    }

        if (requestParameters['notebooks'] != null) {
            requestParameters['notebooks'].forEach((element) => {
                formParams.append('notebooks', element as any);
            })
        }

        const response = await this.request({
            path: `/api/task/{taskId}`.replace(`{${"taskId"}}`, encodeURIComponent(String(requestParameters['taskId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TaskDataFromJSON(jsonValue));
    }

    /**
     * Обновляет информацию о задании по его идентификатору.
     * Редактировать задание
     */
    async editTask(requestParameters: EditTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TaskData> {
        const response = await this.editTaskRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Возвращает список всех заданий.
     * Получить все задания
     */
    async getAllTasksRaw(requestParameters: GetAllTasksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<TaskData>>> {
        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['title'] != null) {
            queryParameters['title'] = requestParameters['title'];
        }

        if (requestParameters['startDate'] != null) {
            queryParameters['start_date'] = (requestParameters['startDate'] as any).toISOString().substring(0,10);
        }

        if (requestParameters['endDate'] != null) {
            queryParameters['end_date'] = (requestParameters['endDate'] as any).toISOString().substring(0,10);
        }

        if (requestParameters['authorName'] != null) {
            queryParameters['authorName'] = requestParameters['authorName'];
        }

        if (requestParameters['status'] != null) {
            queryParameters['status'] = requestParameters['status'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/tasks`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TaskDataFromJSON));
    }

    /**
     * Возвращает список всех заданий.
     * Получить все задания
     */
    async getAllTasks(requestParameters: GetAllTasksRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<TaskData>> {
        const response = await this.getAllTasksRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Возвращает всю информацию о задании по его идентификатору.
     * Получить задание по ID
     */
    async getTaskRaw(requestParameters: GetTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TaskData>> {
        if (requestParameters['taskId'] == null) {
            throw new runtime.RequiredError(
                'taskId',
                'Required parameter "taskId" was null or undefined when calling getTask().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/task/{taskId}`.replace(`{${"taskId"}}`, encodeURIComponent(String(requestParameters['taskId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TaskDataFromJSON(jsonValue));
    }

    /**
     * Возвращает всю информацию о задании по его идентификатору.
     * Получить задание по ID
     */
    async getTask(requestParameters: GetTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TaskData> {
        const response = await this.getTaskRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
